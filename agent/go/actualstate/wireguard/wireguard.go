package wireguard

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/intunderflow/metal/config"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"sync"
	"time"
)

type Wireguard interface {
	GetPublicKey() (string, error)
	GetCurrentlyAppliedSpec() *config.WireguardSpec
	ApplySpec(*config.WireguardSpec) error
	CheckHealthy(context.Context) error
	RestartService(context.Context) error
}

func NewWireguard(nodeID string, wireguardKeyPath string, wireguardConfigFilePath string, wireguardSystemdName string) Wireguard {
	wireguardSpecFilePath := wireguardConfigFilePath + ".metalwgspec.json"
	wireguardSpecNow, err := wireguardSpecFromFile(wireguardSpecFilePath)
	if err != nil {
		fmt.Printf("error getting current wireguard spec, will continue with empty: %v\n", err)
		wireguardSpecNow = nil
	}
	return &wireguardImpl{
		mutex:                   &sync.RWMutex{},
		nodeID:                  nodeID,
		wireguardKeyPath:        wireguardKeyPath,
		wireguardConfigFilePath: wireguardConfigFilePath,
		wireguardSpecFilePath:   wireguardSpecFilePath,
		wireguardSystemdName:    wireguardSystemdName,
		currentAppliedSpec:      wireguardSpecNow,
		lastRestart:             time.Unix(0, 0),
	}
}

type wireguardImpl struct {
	mutex                   *sync.RWMutex
	nodeID                  string
	wireguardKeyPath        string
	wireguardConfigFilePath string
	wireguardSpecFilePath   string
	wireguardSystemdName    string
	currentAppliedSpec      *config.WireguardSpec
	lastRestart             time.Time
}

func (w *wireguardImpl) GetPublicKey() (string, error) {
	w.mutex.RLock()
	defer w.mutex.RUnlock()

	publicKeyBytes, err := os.ReadFile(w.wireguardKeyPath + ".public")
	if err != nil {
		return "", err
	}

	return string(publicKeyBytes), nil
}

func (w *wireguardImpl) getPrivateKey() (string, error) {
	privateKeyBytes, err := os.ReadFile(w.wireguardKeyPath)
	if err != nil {
		return "", err
	}

	return string(privateKeyBytes), nil
}

func (w *wireguardImpl) GetCurrentlyAppliedSpec() *config.WireguardSpec {
	w.mutex.RLock()
	defer w.mutex.RUnlock()
	return w.currentAppliedSpec
}

func (w *wireguardImpl) ApplySpec(spec *config.WireguardSpec) error {
	w.mutex.Lock()
	defer w.mutex.Unlock()
	marshalledWireguardSpec, err := json.Marshal(spec)
	if err != nil {
		return err
	}
	privateKey, err := w.getPrivateKey()
	if err != nil {
		return err
	}
	err = os.WriteFile(w.wireguardConfigFilePath, []byte(wireguardSpecToFile(spec.SelfPeer, spec, privateKey)), 0600)
	if err != nil {
		return err
	}
	err = os.WriteFile(w.wireguardSpecFilePath, marshalledWireguardSpec, 0600)
	if err != nil {
		return err
	}
	w.currentAppliedSpec = spec
	// Restart wireguard service
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	err = exec.CommandContext(ctx, "systemctl", "daemon-reload").Run()
	if err != nil {
		return err
	}
	err = exec.CommandContext(ctx, "systemctl", "restart", w.wireguardSystemdName).Run()
	if err != nil {
		return err
	}
	return nil
}

func wireguardSpecToFile(ourPeer config.WireguardPeer, spec *config.WireguardSpec, privateKey string) string {
	specContent := "# Generated by metal at " + time.Now().String() + "\n"
	specContent = specContent + "[Interface]\n"
	specContent = specContent + "PrivateKey = " + privateKey + "\n"
	specContent = specContent + "Address = " + ourPeer.BindLocalIP + "/24\n"
	specContent = specContent + "ListenPort = " + strconv.Itoa(ourPeer.Port) + "\n"
	for _, peer := range spec.Peers {
		specContent = specContent + "\n"
		specContent = specContent + "# Peer " + strings.ReplaceAll(peer.PeerID, "\n", "") + "\n"
		specContent = specContent + "[Peer]\n"
		specContent = specContent + "PublicKey = " + peer.PublicKey + "\n"
		specContent = specContent + "AllowedIPs = " + peer.BindLocalIP + "/32\n"
		specContent = specContent + "Endpoint = " + peer.Endpoint + ":" + strconv.Itoa(peer.Port) + "\n"
	}
	return specContent
}

func wireguardSpecFromFile(filePath string) (*config.WireguardSpec, error) {
	wireguardSpecBytes, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}
	var wireguardSpec config.WireguardSpec
	err = json.Unmarshal(wireguardSpecBytes, &wireguardSpec)
	if err != nil {
		return nil, err
	}
	return &wireguardSpec, nil
}

func (w *wireguardImpl) CheckHealthy(ctx context.Context) error {
	command := exec.CommandContext(ctx, "systemctl", "status", w.wireguardSystemdName, "--no-pager")
	output, err := command.CombinedOutput()
	if err != nil {
		return err
	}
	if strings.Contains(string(output), "active (running)") || strings.Contains(string(output), "status=0/SUCCESS") {
		return nil
	}
	return errors.New(string(output))
}

func (w *wireguardImpl) RestartService(ctx context.Context) error {
	w.mutex.Lock()
	defer w.mutex.Unlock()

	if w.lastRestart.Add(time.Minute).After(time.Now()) {
		// Don't try restarting if its been less than a minute
		return nil
	}
	w.lastRestart = time.Now()

	return exec.CommandContext(ctx, "systemctl", "restart", w.wireguardSystemdName).Run()
}
